<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>What is Credit Scoring?</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>What is Credit Scoring?</h1>

<p>This package has been developed as part of a CIFRE PhD, a special PhD contract in France which is for the most part financed by a company. This company subsequently gets to choose which subject(s) are tackled.</p>

<p>This research has been financed by Crédit Agricole Consumer Finance (CA CF), subsidiary of the Crédit Agricole Group which provides all kinds of banking and insurance services. CA CF focuses on consumer loans, ranging from luxury cars to small electronics.</p>

<p>In order to accept / reject loan applications more efficiently (both quicker and to select better applicants), most financial institutions resort to Credit Scoring: given the applicant&#39;s characteristics he/she is given a Credit Score, which has been statistically designed using previously accepted applicants, and which partly decides whether the financial institution will grant the loan or not.</p>

<h2>Context</h2>

<p>In practice, the statistical modeler has historical data about each customer&#39;s characteristics. For obvious reasons, only data available at the time of inquiry must be used to build a future application scorecard. Those data often take the form of a well-structured table with one line per client alongside their performance (did they pay back their loan or not?) as can be seen in the following table:</p>

<table><thead>
<tr>
<th align="left">Job</th>
<th align="left">Habitation</th>
<th align="right">Time_in_job</th>
<th align="right">Children</th>
<th align="left">Family_status</th>
<th align="left">Default</th>
</tr>
</thead><tbody>
<tr>
<td align="left">Craftsman</td>
<td align="left">Owner</td>
<td align="right">10</td>
<td align="right">0</td>
<td align="left">Divorced</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Technician</td>
<td align="left">Renter</td>
<td align="right">20</td>
<td align="right">1</td>
<td align="left">Widower</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Executive</td>
<td align="left">Starter</td>
<td align="right">5</td>
<td align="right">2</td>
<td align="left">Single</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Office employee</td>
<td align="left">By family</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="left">Married</td>
<td align="left">No</td>
</tr>
</tbody></table>

<h2>Formulation</h2>

<p>The variable to predict, here denoted by \emph{Default}, is an active research field and we will not discuss it here. We suppose we already have a binary random variable \(Y\) from which we have \(n\) observations \(\mathbf{y} = (y_i)_1^n\).</p>

<p>The \(d\) predictive features, here for example the job, habitation situation, etc., are usually socio-demographic features asked by the financial institutions at the time of application. They are denoted by the random vector \(\boldsymbol{X} = (X_j)_1^d\) and as for \(Y\) we have \(n\) observations \(\mathbf{x}=(x_i)_1^n\).</p>

<p>We suppose that observations \((\mathbf{x},\mathbf{y})\) come from an unknown distribution \(p(x,y)\) which is not directly of interest. Our interest lies in the conditional probability of a client with characteristics \(\boldsymbol{x}\) of paying back his loan, i.e. \(p(y|\boldsymbol{x})\), also unknown.</p>

<p>In the context of Credit Scoring, we historically stick to logistic regression, for various reasons out of the scope of this vignette. The logistic regression model assumes the following relation between \(\boldsymbol{X}\) (supposed continuous here) and \(Y\):
\[\ln \left( \frac{p_{\boldsymbol{\theta}}(Y=1|\boldsymbol{x})}{p_{\boldsymbol{\theta}}(Y=0|\boldsymbol{x})} \right) = (1, \boldsymbol{x})&lsquo;{\boldsymbol{\theta}}\]</p>

<p>We would like to have the ‘‘best&#39;&#39; model compared to the true \(p(y|\boldsymbol{x})\) from which we only have samples. Had we access to the true underlying model, we would like to minimize, w.r.t. \({\boldsymbol{\theta}}\), \(H_{\boldsymbol{\theta}} = \mathbb(E)_{(X,Y) \sim p}[\ln(p_{\boldsymbol{\theta}}(Y|\boldsymbol{X}))]\). Since this is not possible, we approximate this criterion by maximizing, w.r.t. \(\theta\), the likelihood \(\ell({\boldsymbol{\theta}};\mathbf{x},\mathbf{y}) = \sum_{i=1}^n \ln(p_{\boldsymbol{\theta}}(y_i|\boldsymbol{x}_i))\).</p>

<p>In R, this is done by fitting a \code{glm} model to the data:</p>

<pre><code class="r">library(scoringTools)
scoring_model &lt;- glm(Default ~ ., data = lendingClub, family = binomial(link = &quot;logit&quot;))
</code></pre>

<pre><code>## Warning: glm.fit: fitted probabilities numerically 0 or 1 occurred
</code></pre>

<p>We can now focus on the regression coefficients \(\boldsymbol{\theta}\):</p>

<pre><code>##                    (Intercept)               Amount_Requested 
##                   5.446254e-01                   5.198134e-06 
##        Loan_Purposecredit_card Loan_Purposedebt_consolidation 
##                  -2.161336e-01                  -4.537949e-01 
##        Loan_Purposeeducational   Loan_Purposehome_improvement 
##                   1.858680e-01                  -6.656963e-01 
##              Loan_Purposehouse     Loan_Purposemajor_purchase 
##                  -1.278938e+00                  -1.726151e+00 
##            Loan_Purposemedical             Loan_Purposemoving 
##                  -7.204768e-01                  -4.125148e-01 
##              Loan_Purposeother   Loan_Purposerenewable_energy 
##                  -1.044591e-01                  -1.902471e+01 
##     Loan_Purposesmall_business           Loan_Purposevacation 
##                  -7.710864e-01                  -8.271925e-01 
##            Loan_Purposewedding                    Loan_Length 
##                  -4.670372e-01                  -8.072343e-03 
##           Debt_To_Income_Ratio          Home_OwnershipMORTAGE 
##                   4.673087e-04                  -9.385231e-01 
##          Home_OwnershipMORTGAE          Home_OwnershipMORTGAG 
##                  -4.822148e-02                  -1.559521e+00 
##         Home_OwnershipMORTGAGE          Home_OwnershipMORTGGE 
##                  -9.395086e-01                  -1.053046e+00 
##          Home_OwnershipMOTGAGE          Home_OwnershipMRTGAGE 
##                  -1.320655e-01                   7.277748e-02 
##          Home_OwnershipORTGAGE            Home_OwnershipOTHER 
##                  -4.190851e-01                  -2.067367e+01 
##              Home_OwnershipOWN             Home_OwnershipRENT 
##                  -1.052071e+00                  -7.275610e-01 
##              Open_CREDIT_Lines       Revolving_CREDIT_Balance 
##                  -1.537008e-02                   5.409573e-06 
## Inquiries_in_the_Last_6_Months                 Monthly_Income 
##                  -5.478806e-02                   1.679455e-05 
##              Employment_Length                        StateAL 
##                   2.190715e-02                  -9.302735e-01 
##                        StateAR                        StateAZ 
##                  -2.001419e+01                  -8.498573e-01 
##                        StateCA                        StateCO 
##                  -1.324136e+00                  -8.503792e-01 
##                        StateCT                        StateDC 
##                  -1.006930e+00                  -8.278092e-01 
##                        StateDE                        StateFL 
##                  -1.813406e+01                  -7.749171e-01 
##                        StateGA                        StateHI 
##                  -1.658919e+00                  -8.162135e-01 
##                        StateIA                        StateIL 
##                  -2.456610e+00                  -8.436800e-01 
##                        StateIN                        StateKS 
##                  -1.028000e+00                  -1.184442e+00 
##                        StateKY                        StateLA 
##                  -2.489800e+00                  -1.522087e+00 
##                        StateMA                        StateMD 
##                  -2.233885e+00                  -6.024556e-01 
##                        StateMI                        StateMN 
##                  -4.866130e-02                  -1.755743e+00 
##                        StateMO                        StateMS 
##                  -1.490269e+00                  -1.272611e+00 
##                        StateMT                        StateNC 
##                  -2.953696e-01                  -1.296718e+00 
##                        StateNH                        StateNJ 
##                  -9.519204e-01                  -1.139183e+00 
##                        StateNM                        StateNV 
##                  -5.655698e-01                  -1.188136e+00 
##                        StateNY                        StateOH 
##                  -6.806718e-01                  -7.549876e-01 
##                        StateOK                        StateOR 
##                  -2.235123e+00                  -1.849957e+00 
##                        StatePA                        StateRI 
##                  -8.662468e-01                  -1.162867e-01 
##                        StateSC                        StateSD 
##                  -1.620496e+00                   1.488559e+01 
##                        StateTX                        StateUT 
##                  -1.195268e+00                  -1.546485e+00 
##                        StateVA                        StateVT 
##                  -8.237064e-01                   3.419687e-01 
##                        StateWA                        StateWI 
##                  -1.026220e+00                  -5.139766e-01 
##                        StateWV                        StateWY 
##                  -8.625548e-01                  -1.224568e+00 
##                  Interest_Rate              FICO_Range645-649 
##                   3.282162e-02                  -1.933897e+01 
##              FICO_Range650-654              FICO_Range655-659 
##                   2.331851e+01                   2.633920e+00 
##              FICO_Range660-664              FICO_Range665-669 
##                   9.115198e-01                   5.946684e-01 
##              FICO_Range670-674              FICO_Range675-679 
##                   1.004201e+00                   9.227298e-01 
##              FICO_Range680-684              FICO_Range685-689 
##                   7.418759e-01                   1.059893e+00 
##              FICO_Range690-694              FICO_Range695-699 
##                   6.573794e-01                  -1.914143e+01 
##              FICO_Range700-704              FICO_Range705-709 
##                  -1.916224e+01                  -1.916976e+01 
##              FICO_Range710-714              FICO_Range715-719 
##                  -1.907579e+01                  -3.016283e+01 
##              FICO_Range720-724              FICO_Range725-729 
##                  -1.890553e+01                  -3.031735e+01 
##              FICO_Range730-734              FICO_Range735-739 
##                  -1.903904e+01                  -1.898787e+01 
##              FICO_Range740-744              FICO_Range745-749 
##                  -1.901698e+01                  -1.899618e+01 
##              FICO_Range750-754              FICO_Range755-759 
##                  -1.904364e+01                  -1.898244e+01 
##              FICO_Range760-764              FICO_Range765-769 
##                  -1.883702e+01                  -1.871614e+01 
##              FICO_Range770-774              FICO_Range775-779 
##                  -1.888484e+01                  -1.870410e+01 
##              FICO_Range780-784              FICO_Range785-789 
##                  -1.877299e+01                  -1.889972e+01 
##              FICO_Range790-794              FICO_Range795-799 
##                  -1.882304e+01                  -1.947507e+01 
##              FICO_Range800-804              FICO_Range805-809 
##                  -1.877842e+01                  -3.202823e+01 
##              FICO_Range810-814              FICO_Range815-819 
##                  -1.877796e+01                  -1.899147e+01 
##              FICO_Range820-824              FICO_Range830-834 
##                  -1.776919e+01                  -1.902438e+01 
##                            Age 
##                  -3.512107e-03
</code></pre>

<p>and the deviance at this estimation of \(\boldsymbol{\theta}\):
[1] 1103.43</p>

<p>From this, it seems that Credit Scoring is pretty straightforward when the data is at hand.</p>

<h2>Conceptual problems of current approaches to Credit Scoring</h2>

<p>Nevertheless, there are a few theoretical limitations of the current approach, e.g.:</p>

<ul>
<li>We don&#39;t observe rejected applicants&#39;s performance, i.e. we don&#39;t have observations \(y_i\) for previously rejected applicants;</li>
<li>The performance variable \(Y\) must be constructed using historical data but we can&#39;t wait for all current contracts to end, that&#39;s why financial institutions usually consider a defaulting client to be someone failing to pay two consecutive installments;</li>
<li>Credit risk modelers often ‘‘discretize&#39;&#39; the input data \(\boldsymbol{X}\), that is to say continuous variables are transformed into categorical variables corresponding to intervals of the support of \(\boldsymbol{X}\) and categorical variables might see their values regrouped to form a categorical variable with less values (but whose coefficients are ‘‘easier&#39;&#39; to estimate). Up to now, there was no theoretical grounds to do so and no uniformly better method;</li>
<li>Credit risk modelers have always sticked to logistic regression without knowing whether it is somewhat ‘‘close&#39;&#39; to the true underlying model.</li>
</ul>

<h2>Problems tackled in this package</h2>

<p>Two problems have been tackled so far in the Credit Scoring framework:</p>

<ol>
<li>Reject Inference,</li>
<li>‘‘Quantization&#39;&#39; of continuous (discretization) and qualitative (grouping) features,</li>
</ol>

<h2>Other packages</h2>

<p>We released two other packages:</p>

<ol>
<li>Package <a href="https://cran.r-project.org/package=glmdisc">glmdisc</a> for ‘‘Quantization&#39;&#39; of continuous (discretization) and qualitative (grouping) features <strong>and</strong> interactions among covariates,</li>
<li>Package <a href="https://cran.r-project.org/package=glmtree">glmtree</a> for ‘‘Segmentation&#39;&#39; of clients into subpopulations with different scorecards: logistic regression trees.</li>
</ol>

<p>Other packages focus on Credit Scoring, see e.g. <a href="https://arxiv.org/abs/2006.11835">this review paper</a>.</p>

<h1>Reject Inference</h1>

<h2>Context</h2>

<h3>Current acceptance system</h3>

<p>From all applicants who get a Credit Score, there are three interesting sub-populations: the financed clients, who were granted a loan, the rejected applicants, who were rejected either by business rules (e.g. over-indebtedness) or because of a low Credit Score, and the not-taking up applicants who were offered a loan but decided not to take it (e.g. they don&#39;t need it anymore or they went to a competitor).</p>

<p>Obviously, the performance variable \(Y\) is observed only for financed clients so that we have \(n\) observations of financed clients \((\boldsymbol{x}_i,y_i)_1^n\) and \(n&rsquo;\) observations of not financed clients for who we only have the characteristics \((\boldsymbol{x}_i)_1^{n'}\).</p>

<h3>Mathematical formulation</h3>

<p>Strictly speaking, we have observations from \(p(\boldsymbol{x},y,Z=f)\) and by fitting a logistic regression to this data, we subsequently estimate \(p(y|\boldsymbol{x},Z=f)\) which is quite ‘‘different&#39;&#39; from \(p(y|\boldsymbol{x})\). Since the Credit Score is to be applied to the whole population to decide whether to accept/reject clients, it seems that this can lead to a biased model, even asymptotically.</p>

<p>There are three important keys to understand if the resulting model is biased:</p>

<ul>
<li>Is the model local or global, i.e. does it compute \(p(y|\boldsymbol{x})\) directly or does it have to model \(p(\boldsymbol{x},y)\) and then deduce \(p(y|\boldsymbol{x})\) in which case it is necessarily biased?</li>
<li>Is the model ‘‘true&#39;&#39;, i.e. is there any \(\boldsymbol{\theta}\) such that \(p(y|\boldsymbol{x}) = p_{\boldsymbol{\theta}}(y|\boldsymbol{x})\)?</li>
<li>What is the missingness mechanism? Following Rubin&#39;s definition it can be MCAR (missingness of \(y\) is indepedent of any variable), MAR (missingness of \(y\) only depends on \(\boldsymbol{x}\)) or MNAR (there are unobserved variables that determine \(y\)&#39;s missingness).</li>
</ul>

<h2>Theoretical findings</h2>

<p>Our theoretical findings on this subject is discussed in <a href="https://arxiv.org/abs/1903.10855">Ehrhardt et al. (2017)</a>.</p>

<p>In short, using only financed clients&#39; characteristics to learn a logistic regression model is asymptotically correct when the missingness mechanism is MAR and the model is true. We can easily show this by simulating data:</p>

<pre><code class="r">data_cont_simu &lt;- function(n, d, k) {
  set.seed(k)
  x &lt;- matrix(runif(n * d), nrow = n, ncol = d)
  theta &lt;- c(1, -1)
  log_odd &lt;- x %*% theta

  y &lt;- rbinom(n, 1, 1 / (1 + exp(-log_odd)))

  return(list(x, y))
}

if (require(ggplot2, quietly = TRUE)) {
  data &lt;- data_cont_simu(100, 2, 1)
  x &lt;- data[[1]]
  y &lt;- data[[2]]
  df &lt;- data.frame(x = x, y = y)
  ggplot(df, aes(x = x.1, y = x.2, colour = factor(y))) +
    geom_point()

  data &lt;- data_cont_simu(1000, 2, 1)
  x &lt;- data[[1]]
  y &lt;- data[[2]]
  df &lt;- data.frame(x = x, y = y)
  hat_theta &lt;- glm(y ~ . - 1, data = df, family = binomial(link = &quot;logit&quot;))
  df$decision &lt;- factor(ifelse(predict(hat_theta, df, type = &quot;response&quot;) &gt; 0.7, &quot;reject&quot;, &quot;accept&quot;))
  ggplot(df, aes(x = x.1, y = x.2, colour = decision)) +
    geom_point()

  theta_1 &lt;- matrix(NA, ncol = 1, nrow = 1000)
  theta_2 &lt;- matrix(NA, ncol = 1, nrow = 1000)
  theta_1_f &lt;- matrix(NA, ncol = 1, nrow = 1000)
  theta_2_f &lt;- matrix(NA, ncol = 1, nrow = 1000)
  for (k in 1:1000) {
    data &lt;- data_cont_simu(1000, 2, k)
    x &lt;- data[[1]]
    y &lt;- data[[2]]
    df &lt;- data.frame(x = x, y = y)
    hat_theta &lt;- glm(y ~ . - 1, data = df, family = binomial(link = &quot;logit&quot;))

    theta_1[k] &lt;- hat_theta$coefficients[1]
    theta_2[k] &lt;- hat_theta$coefficients[2]

    df$decision &lt;- factor(ifelse(predict(hat_theta, df, type = &quot;response&quot;) &gt; 0.6, &quot;reject&quot;, &quot;accept&quot;))
    hat_theta_f &lt;- glm(y ~ . - 1, data = df[df$decision == &quot;accept&quot;, -ncol(df)], family = binomial(link = &quot;logit&quot;))

    theta_1_f[k] &lt;- hat_theta_f$coefficients[1]
    theta_2_f[k] &lt;- hat_theta_f$coefficients[2]
  }
  ggplot(data.frame(theta_1), aes(x = theta_1)) +
    geom_histogram() +
    geom_vline(xintercept = 1)
}
</code></pre>

<pre><code>## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-5"/></p>

<p>When the missingness mechanism is MNAR, \(p(y|\boldsymbol{x},f) \neq p(y|\boldsymbol{x},nf)\) so that there is no way to ‘‘unbias&#39;&#39; the resulting model without introducing data from the financing mechanism and model \(p(f|\boldsymbol{x},y)\).</p>

<p>When the model is false, we could make use of not financed clients to estimate \(p(f|\boldsymbol{x})\) and consider this as an importance function in the Importance Sampling framework. However, this gives good results when the importance function is known and under probabilistic assumptions not met in our use case. Here it must be evaluated separately and simulations show that this estimation process also introduces bias and variance and subsequently does not improve upon the financed clients&#39; model. </p>

<h2>Reject Inference methods</h2>

<p>To deal with the possible bias of fitting a logistic regression to the financed clients&#39; data, Reject Inference methods have been proposed in the literature. We showed in that none of them could potentially give any good result. Nevertheless, we implemented them to compare them numerically.</p>

<h3>Functions</h3>

<p>In this package, we implemented Reject Inference methods which were described for example in and were supposed to enable credit risk modelers to use not-financed clients&#39; characteristics in the logistic regression learning process. We demonstrated that these methods are not statistically grounded. We nevertheless implemented these methods to show these results numerically.</p>

<p>The first method is Fuzzy Augmentation as described in the Appendix of <a href="https://github.com/adimajo/manuscrit_these">my PhD thesis</a>.</p>

<pre><code class="r">xf &lt;- as.matrix(df[df$decision == &quot;accept&quot;, c(&quot;x.1&quot;, &quot;x.2&quot;)])
xnf &lt;- as.matrix(df[df$decision == &quot;reject&quot;, c(&quot;x.1&quot;, &quot;x.2&quot;)])
yf &lt;- df[df$decision == &quot;accept&quot;, &quot;y&quot;]
hat_theta_fuzzy &lt;- fuzzy_augmentation(xf, xnf, yf)
</code></pre>

<pre><code>## Warning in eval(family$initialize): non-integer #successes in a binomial glm!
</code></pre>

<p>The second method is Reclassification as described in the Appendix of <a href="https://github.com/adimajo/manuscrit_these">my PhD thesis</a>.</p>

<pre><code class="r">hat_theta_reclassification &lt;- reclassification(xf, xnf, yf)
</code></pre>

<p>The third method is Augmentation as described in the Appendix of <a href="https://github.com/adimajo/manuscrit_these">my PhD thesis</a>.</p>

<pre><code class="r">hat_theta_augmentation &lt;- augmentation(xf, xnf, yf)
</code></pre>

<pre><code>## Warning in eval(family$initialize): non-integer #successes in a binomial glm!
</code></pre>

<p>The fourth method is Parcelling as described in the Appendix of <a href="https://github.com/adimajo/manuscrit_these">my PhD thesis</a>.</p>

<pre><code class="r">hat_theta_parcelling &lt;- parcelling(xf, xnf, yf)
</code></pre>

<p>The fifth method is Twins as described in the Appendix of <a href="https://github.com/adimajo/manuscrit_these">my PhD thesis</a>.</p>

<pre><code class="r">hat_theta_twins &lt;- twins(xf, xnf, yf)
</code></pre>

<pre><code>## Warning in speedglm::speedglm(acc ~ ., family = stats::binomial(link =
## &quot;logit&quot;), : Maximum number of iterations reached without convergence
</code></pre>

<p>Each of these functions output an S4 object named ‘‘reject_infered&#39;&#39;. This object has slots:</p>

<ul>
<li>method_name: the Reject Inference method used;</li>
<li>financed_model: the logistic regression using only financed clients&#39; characteristics;</li>
<li>acceptance_model: the logistic regression modeling the financing decision (empty for all methods except Augmentation and Twins);</li>
<li>infered_model: the logistic regression obtained using a given reject inference technique.</li>
</ul>

<pre><code class="r">hat_theta_augmentation@method_name
</code></pre>

<pre><code>## [1] &quot;augmentation&quot;
</code></pre>

<pre><code class="r">hat_theta_reclassification@financed_model
</code></pre>

<pre><code>## Generalized Linear Model of class &#39;speedglm&#39;:
## 
## Call:  speedglm::speedglm(formula = labels ~ ., data = df_f, family = stats::binomial(link = &quot;logit&quot;)) 
## 
## Coefficients:
## (Intercept)        x.x.1        x.x.2  
##   -0.001515     1.493633    -1.570911
</code></pre>

<pre><code class="r">hat_theta_twins@acceptance_model
</code></pre>

<pre><code>## Generalized Linear Model of class &#39;speedglm&#39;:
## 
## Call:  speedglm::speedglm(formula = acc ~ ., data = df[, -which(names(df) %in%      c(&quot;labels&quot;))], family = stats::binomial(link = &quot;logit&quot;)) 
## 
## Coefficients:
## (Intercept)        x.x.1        x.x.2  
##        1754        -5037         5753
</code></pre>

<pre><code class="r">hat_theta_fuzzy@infered_model
</code></pre>

<pre><code>## Generalized Linear Model of class &#39;speedglm&#39;:
## 
## Call:  speedglm::speedglm(formula = labels ~ ., data = df[, -which(names(df) %in%      c(&quot;acc&quot;))], family = stats::binomial(link = &quot;logit&quot;)) 
## 
## Coefficients:
## (Intercept)        x.x.1        x.x.2  
##   -0.001515     1.493633    -1.570911
</code></pre>

<h3>Methods</h3>

<p>To efficiently use the generated S4 objects of class ‘‘reject_infered&#39;&#39; several methods were implemented which we detail here.</p>

<h4>print method</h4>

<p>The print method shows the method used and the coefficients of infered_model, much like you would get from printing a \code{glm} object:
Generalized Linear Model of class &#39;speedglm&#39;:</p>

<p>Call:  speedglm::speedglm(formula = labels ~ ., data = df[, -which(names(df) %in%      c(&ldquo;acc&rdquo;))], family = stats::binomial(link = &ldquo;logit&rdquo;)) </p>

<p>Coefficients:
(Intercept)        x.x.1        x.x.2<br/>
     0.3168       2.5703      -2.7744  </p>

<h4>summary method</h4>

<p>The summary method shows the method used alongside the coefficients of the financed model, eventually the acceptance model and the infered model with AIC values, much like you would get from doing a summary on a \code{glm} object:
        Length          Class           Mode 
             1 reject_infered             S4 </p>

<h1>Quantization</h1>

<h2>Context</h2>

<p>Under the term ‘‘quantization&#39;&#39;, we refer to the process of transforming a continuous feature into a categorical feature which values uniquely correspond to intervals of the continuous feature and to the process of regrouping values of categorical feature.</p>

<p>There are a few advantages to discretizing the input features:</p>

<ul>
<li>Interpretability: the logistic regression becomes a simple addition;</li>
<li>Usability in other areas: we can address subgroups by focusing on one or several values of a given discretized feature;</li>
<li>Outliers have less influence in model fitting because they are regrouped in the first (or last) value of the discretized feature;</li>
<li>Non-linearity of the continuous value w.r.t. the log odd ratio: the real log odd ratio of each feature (all else equal) is considered linear in the logistic regression equation which might not be true. By discretizing each feature, we perform stepwise approximation.</li>
</ul>

<p>There are a few drawbacks as well:</p>

<ul>
<li>Pre-processing task that can be costly in both human and computation time;</li>
<li>Loss in predictive power if continuous model is closer to the true model;</li>
<li>Harder to estimate each coefficient as there are more coefficients and subsequently less data to estimate each of them.</li>
</ul>

<p>These advantages and drawbacks are explained in-depth in .</p>

<p>Despite its limitations, CA CF decided to go on developping their scorecards by using logistic regression and discretizing their input features. However, with the growing number of input features in an era of Big Data, the increasing number of products and types of clients addressed and the simultaneous aging of their previous scorecards, they decided to have an automatic tool to generate production-ready scorecards by automizing the discretization process under constraints (which we&#39;ll develop later on) and the logistic regression fitting. They had to be confident on the underlying mechanisms of this tool (mathematically speaking) that is why it became a research project. We first delve into the mathematics of the problem.</p>

<h2>Mathematical reinterpretation</h2>

<h3>Model</h3>

<p>We consider a random vector \(\boldsymbol{X}=(X_1,X_d)\) where \(X_j\) can be either continuous or qualitative (with \(o_j\) distinct values). We denote by \(\boldsymbol{\mathfrak{q}}=(\mathfrak{q}_1,\mathfrak{q}_d)\) the quantized random vector where \(\mathfrak{q}_j\) is the quantization of \(X_j\), i.e. qualitative with \(m_j\) values corresponding either to unique intervals of \(X_j\) (continuous case) or to unique regroupments of \(X_j\)&#39;s \(o_j\) values (which implies \(m_j \leq o_j\)).</p>

<p>We suppose that by quantizing features \(\boldsymbol{X}\), we preserve all information about the target feature, i.e. \(p(y|\boldsymbol{x},\boldsymbol{\mathfrak{q}}) = p(y|\boldsymbol{\mathfrak{q}})\).</p>

<h3>Hard optimization problem</h3>

<p>Although this process seems straightforward, it is a rather complicated optimization problem in terms of combinatorics and estimation (being a discrete problem).</p>

<h3>Choosing the ‘‘right&#39;&#39; model: which criterion?</h3>

<p>The task is to find the optimal logistic regression \(p_{\boldsymbol{\theta}}(y|\boldsymbol{\mathfrak{q}})\) where \(\boldsymbol{\mathfrak{q}}\) is unknown and must be chosen in a set \(\mathbf{\mathfrak{Q}}_{\boldsymbol{m}}\) very large as said in the previous section. So the model selection problem can be expressed in terms of classical criteria, e.g. AIC, BIC, \ldots where \Theta and \(\mathbf{\mathfrak{Q}}_{\boldsymbol{m}}\) have to be scanned:</p>

<p>\[ (\hat{\boldsymbol{\theta}}, \hat{\boldsymbol{\mathfrak{q}}}) = \arg \max_{(\boldsymbol{\theta},\boldsymbol{\mathfrak{q}})} \text{AIC}(p_{\boldsymbol{\theta}}(\mathbf{y}|\mathbf{\mathfrak{q}})).\]</p>

<h3>The need for generating ‘‘clever&#39;&#39; candidates</h3>

<p>The criterion developed in the previous part cannot be optimized directly because the set \(\mathbf{\mathfrak{Q}}_{\boldsymbol{m}}\) of candidate discretizations is too large. The idea behind most existing supervised discretization method is to generate potentially ‘‘good&#39;&#39; candidates (although most methods don&#39;t depend on the predictive algorithm to be applied after discretization).</p>

<p>By doing so, we reduce elements of \(\mathbf{\mathfrak{Q}}_{\boldsymbol{m}}\) to the generated candidates which is a considerably smaller set, with most existing methods outputing only one discretization scheme. We go through a few of them in the next section.</p>

<p>We proposed a discretization algorithm that meets these criteria and naturally . It was described in <arxiv:>.</p>

<p>In short, the algorithm considers the discretized features \(\boldsymbol{\mathfrak{q}}\) as latent variables which we will generate from its estimated a posteriori density function as part of an SEM-algorithm (see ). The algorithm alternates between:</p>

<ol>
<li>Fitting a logistic regression between \(\boldsymbol{\mathfrak{q}}\) and \(y\);</li>
<li>Fitting polytomous logistic regression functions between each pair of \((x_j,\mathfrak{q}_j)\);</li>
<li>Generate new discretized features \(E\) by sampling them, as \(p(\mathfrak{q}_j|\mathfrak{q}_{-\{j\}},\boldsymbol{x},y) \propto p(\mathfrak{q}_j|x_j) p(y|\boldsymbol{\mathfrak{q}})\).</li>
</ol>

<p>The approach is implemented in the <code>glmdisc</code> package and <strong>is not part of this package</strong>. Please refer to its vignette (by typing <code>vignette(&quot;glmdisc&quot;)</code>).</p>

<h2>Existing methods</h2>

<h3>The discretization package</h3>

<p>In this package, we wrapped functions of the <a href="https://cran.r-project.org/package=discretization">discretization</a> package in a unified S4 class <code>discretization</code>.</p>

<pre><code class="r">x &lt;- matrix(runif(300), nrow = 100, ncol = 3)
cuts &lt;- seq(0, 1, length.out = 4)
xd &lt;- apply(x, 2, function(col) as.numeric(cut(col, cuts)))
theta &lt;- t(matrix(c(0, 0, 0, 2, 2, 2, -2, -2, -2), ncol = 3, nrow = 3))
log_odd &lt;- rowSums(t(sapply(seq_along(xd[, 1]), function(row_id) {
  sapply(
    seq_along(xd[row_id, ]),
    function(element) theta[xd[row_id, element], element]
  )
})))
y &lt;- stats::rbinom(100, 1, 1 / (1 + exp(-log_odd)))

discrete_modele &lt;- chi2_iter(x, y)
</code></pre>

<pre><code>## New names:
## * `` -&gt; ...1
## * `` -&gt; ...2
## * `` -&gt; ...3
## New names:
## * `` -&gt; ...1
## * `` -&gt; ...2
## * `` -&gt; ...3
## New names:
## * `` -&gt; ...1
## * `` -&gt; ...2
## * `` -&gt; ...3
</code></pre>

<h3>Methods</h3>

<h4>print method</h4>

<p>The print method shows the method used and the coefficients of infered_model, much like you would get from printing a \code{glm} object:
Generalized Linear Model of class &#39;speedglm&#39;:</p>

<p>Call:  speedglm::speedglm(formula = stats::formula(&ldquo;labels ~ .&rdquo;), data = Filter(function(x) (length(unique(x)) &gt;      1), cbind(data.frame(sapply(disc$Disc.data, as.factor), stringsAsFactors = TRUE),      data_train[, sapply(data_train, is.factor), drop = FALSE])),      family = stats::binomial(link = &ldquo;logit&rdquo;), weights = NULL,      fitted = TRUE) </p>

<p>Coefficients:
(Intercept)          X12          X13<br/>
     -1.224        2.099       -0.622  </p>

<h4>summary method</h4>

<p>The summary method shows the method used alongside the coefficients of the financed model, eventually the acceptance model and the infered model with AIC values, much like you would get from doing a summary on a \code{glm} object:
Generalized Linear Model of class &#39;speedglm&#39;:</p>

<p>Call:  speedglm::speedglm(formula = stats::formula(&ldquo;labels ~ .&rdquo;), data = Filter(function(x) (length(unique(x)) &gt;      1), cbind(data.frame(sapply(disc$Disc.data, as.factor), stringsAsFactors = TRUE),      data_train[, sapply(data_train, is.factor), drop = FALSE])),      family = stats::binomial(link = &ldquo;logit&rdquo;), weights = NULL,      fitted = TRUE) </p>

<p>Coefficients:</p>

<hr/>

<pre><code>        Estimate Std. Error z value Pr(&gt;|z|)    
</code></pre>

<p>(Intercept)   -1.224      0.509  -2.405   0.0162 *<br/>
X12            2.099      0.633   3.317   0.0009 ***
X13           -0.622      0.672  -0.925   0.3547    </p>

<hr/>

<p>Signif. codes:  0 &#39;<em>**&#39; 0.001 &#39;</em><em>&#39; 0.01 &#39;</em>&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 </p>

<hr/>

<p>null df: 99; null deviance: 129;
residuals df: 97; residuals deviance: 99.8;</p>

<h1>obs.: 100; # non-zero weighted obs.: 100;</h1>

<p>AIC: 106; log Likelihood: -49.9;
RSS: 100; dispersion: 1; iterations: 4;
rank: 3; max tolerance: 8.83e-13; convergence: TRUE.</p>

<h4>predict method</h4>

<p>The predict method corresponds to the glm predict method for the infered model:
    1     2     3     4     5     6     7     8     9    10    11    12    13 
0.136 0.706 0.706 0.706 0.136 0.227 0.136 0.227 0.136 0.227 0.227 0.136 0.136 
   14    15    16    17    18    19    20    21    22    23    24    25    26 
0.136 0.227 0.706 0.227 0.227 0.227 0.706 0.136 0.706 0.706 0.136 0.706 0.136 
   27    28    29    30    31    32    33    34    35    36    37    38    39 
0.136 0.227 0.706 0.136 0.227 0.136 0.136 0.136 0.227 0.706 0.706 0.706 0.706 
   40    41    42    43    44    45    46    47    48    49    50    51    52 
0.706 0.136 0.706 0.706 0.227 0.136 0.136 0.136 0.136 0.227 0.136 0.706 0.706 
   53    54    55    56    57    58    59    60    61    62    63    64    65 
0.227 0.136 0.706 0.136 0.227 0.227 0.227 0.136 0.136 0.706 0.706 0.706 0.136 
   66    67    68    69    70    71    72    73    74    75    76    77    78 
0.136 0.706 0.227 0.706 0.706 0.227 0.136 0.136 0.136 0.136 0.136 0.136 0.136 
   79    80    81    82    83    84    85    86    87    88    89    90    91 
0.706 0.706 0.136 0.136 0.706 0.227 0.706 0.136 0.136 0.136 0.706 0.136 0.136 
   92    93    94    95    96    97    98    99   100 
0.706 0.227 0.136 0.227 0.706 0.136 0.706 0.136 0.706 </p>

<h4>plot method</h4>

<p>The plot method corresponds to the glm plot method for the infered model:</p>

<!-- ## Added constraints -->

<!-- ### Few values -->

<!-- ### Interpretability of the intervals -->

<!-- ### Feature selection -->

<!-- ### Automatic creation of interaction terms -->

<h1>Segmentation: logistic regression trees</h1>

<p>Classically, Credit Scoring practioners perform ‘‘segmentation&#39;&#39; before learning a scorecard, i.e. they try to find homogeneous segments of clients, e.g. ‘‘young clients&#39;&#39;, &ldquo;home owners&#39;&#39;, and combine them. They then perform scoring locally, on the resulting leaves of this decision tree. We thus proposed an algorithm to fit this tree and the logistic regressions at its leaves, which we call glmtree. The resulting model mixes non parametric VS parametric and stepwise VS linear approaches to have the best predictive results, yet maintaining interpretability.</p>

<p>The approach is implemented in the <code>glmtree</code> package required by this package. Please refer to its vignette (by typing <code>vignette(&quot;glmtree&quot;)</code>).</p>

</body>

</html>
